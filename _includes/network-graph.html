{% assign height = include.height | default: "75vh" %}
{% assign uid = include.uid | default: "default" %}
{% assign focus_node = include.focus_node | default: "" %}
{% assign focus_tags = page.tags | default: [] %}

<style>
  /* --- Container --- */
  #graph-wrapper-{{ uid }} {
    position: relative;
    height: {{ height }}; 
    width: 100%; 
    margin: 0;
    overflow: hidden;
    background-color: var(--bg-body); 
    border-top: 1px solid var(--border-color);
    border-bottom: 1px solid var(--border-color);
    border-radius: var(--border-radius) var(--border-radius) 0 0;
    box-shadow: var(--shadow-sm);
  }

  /* --- Element Styles --- */
  .zone-ring { fill: none; stroke: var(--border-color); stroke-width: 2px; opacity: 0.8; stroke-dasharray: 4, 6; pointer-events: none; transition: stroke 0.3s ease; }
  @media (prefers-color-scheme: dark) { .zone-ring { stroke: #3a3a3a; opacity: 0.6; } }
  body.dark-mode .zone-ring { stroke: #3a3a3a; opacity: 0.6; }

  .graph-link { stroke: var(--text-muted); stroke-width: 1.5px; opacity: 0.4; transition: all 0.3s ease; }
  @media (prefers-color-scheme: dark) { .graph-link { opacity: 0.3; } }
  body.dark-mode .graph-link { opacity: 0.3; }

  .node-text { font-family: var(--font-family-base); pointer-events: none; fill: var(--text-body); font-weight: 700; text-shadow: -2px -2px 0 var(--bg-body), 2px -2px 0 var(--bg-body), -2px  2px 0 var(--bg-body), 2px  2px 0 var(--bg-body); transition: fill 0.3s ease; }
  .node-circle { cursor: pointer; transition: all 0.4s ease; }
  
  /* Type Colors */
  .node-person { stroke: #20c997; stroke-width: 2px; } 
  .node-platform { stroke: #9467bd; stroke-width: 2px; } 
  .node-org { stroke: var(--chill-color); stroke-width: 2px; } 
  .node-init { stroke: var(--main-color); stroke-width: 2px; }

  /* Bridge Highlight */
  .node-bridge circle { stroke: #ffc107 !important; stroke-width: 5px !important; filter: drop-shadow(0 0 6px rgba(255, 193, 7, 0.8)); }
  .node-bridge text { font-weight: 900 !important; font-size: 11px !important; fill: var(--text-strong) !important; }

  /* Current Page Node */
  .node-current circle { stroke-width: 6px !important; stroke: var(--text-body) !important; stroke-dasharray: 3, 2; }
  .node-current text { font-size: 14px !important; font-weight: 900 !important; text-decoration: underline; }

  /* UI */
  #graph-tooltip { position: absolute; padding: 1rem; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: var(--border-radius); box-shadow: var(--shadow-md); pointer-events: none; opacity: 0; max-width: 280px; z-index: 10; color: var(--text-body); }
  #controls { position: absolute; top: 20px; right: 20px; z-index: 5; }
  #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--text-muted); font-weight: 600; }
  
  /* Legend */
  .legend-wrapper { width: 100%; background: var(--bg-light); border-bottom: 1px solid var(--border-color); border-left: 1px solid var(--border-color); border-right: 1px solid var(--border-color); border-radius: 0 0 var(--border-radius) var(--border-radius); }
  .legend-bar { display: flex; justify-content: center; flex-wrap: wrap; gap: 0.5rem; padding: 1rem; }
  .legend-tag { font-size: 0.85em; padding: 4px 10px; border-radius: 4px; background: var(--bg-card); border: 1px solid var(--border-color); color: var(--text-body); font-weight: 600; border-bottom-width: 3px; display: inline-flex; align-items: center; gap: 6px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
</style>

<div id="graph-wrapper-{{ uid }}">
  <div id="controls">
    <button id="toggle-btn" class="meta-btn">Alles uitklappen</button>
  </div>
  <div id="graph-container" style="width:100%; height:100%;">
    <div id="loading">Laden...</div>
  </div>
  <div id="graph-tooltip"></div>
</div>

<div class="legend-wrapper">
  <div class="legend-bar">
    <span class="legend-tag" style="border-bottom-color: #7f8c8d; border-bottom-width:1px;"><span class="legend-dot" style="border: 2px solid #7f8c8d; background: transparent;"></span> Thema</span>
    <span class="legend-tag" style="border-bottom-color: #ffc107; border-bottom-width:1px;"><span class="legend-dot" style="background: transparent; border: 2px solid #ffc107; box-shadow: 0 0 4px #ffc107;"></span> Verbinder</span>
    <span class="legend-tag" style="border-bottom-color: #20c997">Professional</span>
    <span class="legend-tag" style="border-bottom-color: #9467bd">Platform</span>
    <span class="legend-tag" style="border-bottom-color: var(--chill-color)">Organisatie</span>
    <span class="legend-tag" style="border-bottom-color: var(--main-color)">Initiatief</span>
  </div>
</div>

<div class="text-center mt-sm">
  <small class="text-muted">Visualisatie met <a href="https://github.com/d3/d3/">D3.js</a></small>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
  const container = document.getElementById('graph-wrapper-{{ uid }}');
  const graphDiv = container.querySelector('#graph-container');
  
  // Dimensions
  let width = graphDiv.clientWidth;
  let height = graphDiv.clientHeight;
  let center = { x: width / 2, y: height / 2 };

  // --- VARIABLES PASSED FROM LIQUID ---
  const focusId = "{{ focus_node }}"; 
  
  // FIX: Force empty array if null
  const pageTags = {{ focus_tags | jsonify }} || []; 
  
  const jsonUrl = '{{ include.data | default: "/network.json" }}';

  const config = {
    colors: { "Makers": "#e83e8c", "Open Access": "#dc3545", "Open Source": "#ffc107", "Open Design": "#0dcaf0", "Open GLAM": "#198754", "Open Onderwijs": "#20c997", "Open Onderzoek": "#0d6efd", "Open Overheid": "#6610f2", "Open Zorg": "#fd7e14", "Open Data": "#82c91e", "default": "#7f8c8d" },
    radii: { person: 80, platform: 180, org: 280, tag: 380 }
  };
  const getTagColor = (id) => config.colors[id.replace("tag-", "").replace("/tags/", "").replace("/", "")] || config.colors["default"];

  const svg = d3.select(graphDiv).append("svg")
      .attr("width", "100%").attr("height", "100%")
      .attr("viewBox", [0, 0, width, height])
      .style("cursor", "grab").style("touch-action", "none");

  const g = svg.append("g");
  
  // Draw Background Rings
  const ringData = [config.radii.person, config.radii.platform, config.radii.org, config.radii.tag];
  g.append("g").attr("class", "zones").selectAll("circle").data(ringData).join("circle")
    .attr("class", "zone-ring").attr("cx", center.x).attr("cy", center.y).attr("r", d => d);

  const zoom = d3.zoom().scaleExtent([0.1, 8]).on("zoom", ({transform}) => g.attr("transform", transform));
  svg.call(zoom).on("dblclick.zoom", null);

  // Load Data
  d3.json(jsonUrl).then(function(data) {
    container.querySelector("#loading").remove();

    const nodes = data.nodes.map(d => ({...d}));
    const nodeMap = new Map(nodes.map(d => [d.id, d]));
    const links = data.links.map(d => ({...d})).filter(l => nodeMap.has(l.source) && nodeMap.has(l.target));

    const neighbors = {};
    links.forEach(l => {
      if (!neighbors[l.source]) neighbors[l.source] = [];
      if (!neighbors[l.target]) neighbors[l.target] = [];
      neighbors[l.source].push(l.target);
      neighbors[l.target].push(l.source);
    });

    // --- INITIALIZATION LOGIC ---
    // 1. Reset all to hidden
    nodes.forEach(n => { n.visible = false; n.collapsed = true; });

    let activeMode = "DEFAULT"; 
    const activeTagIds = pageTags.map(t => "tag-" + t);
    
    // Determine Mode
    if (focusId && nodeMap.has(focusId)) {
        activeMode = "FOCUS";
    } else if (activeTagIds.length > 0 && activeTagIds.some(id => nodeMap.has(id))) {
        activeMode = "TAGS";
    }

    if (activeMode === "FOCUS") {
        const target = nodeMap.get(focusId);
        target.visible = true;
        target.isCurrent = true;
        target.x = center.x; target.y = center.y; target.fx = center.x; target.fy = center.y; 

        // Open related tags
        nodes.forEach(n => {
            if (activeTagIds.includes(n.id)) {
                n.visible = true; n.collapsed = false;
                (neighbors[n.id]||[]).forEach(pid => { if(nodeMap.get(pid)) nodeMap.get(pid).visible = true; });
            }
        });
        (neighbors[focusId]||[]).forEach(pid => { if(nodeMap.get(pid)) nodeMap.get(pid).visible = true; });

    } else if (activeMode === "TAGS") {
        // Show pages related to tags
        nodes.forEach(n => {
            if (activeTagIds.includes(n.id)) {
                n.visible = true; n.collapsed = false;
                (neighbors[n.id]||[]).forEach(pid => { if(nodeMap.get(pid)) nodeMap.get(pid).visible = true; });
            }
        });

    } else {
        // DEFAULT
        nodes.forEach(n => {
            if (n.group === 'tag') {
                n.visible = true;
                n.collapsed = true;
                const angle = Math.random() * 2 * Math.PI; 
                n.x = center.x + config.radii.tag * Math.cos(angle);
                n.y = center.y + config.radii.tag * Math.sin(angle);
            }
        });
    }

    const simulation = d3.forceSimulation(nodes)
        .velocityDecay(0.55)
        .force("link", d3.forceLink(links).id(d => d.id).strength(0.02))
        .force("charge", d3.forceManyBody().strength(d => d.group === 'tag' ? -150 : -30))
        .force("collide", d3.forceCollide().radius(d => d.radius + 8).iterations(2))
        .force("r", d3.forceRadial(d => {
            if (d.group === 'tag') return config.radii.tag;
            if (d.type === 'persoon') return config.radii.person;
            if (['Platform', 'Bibliotheek', 'Studio', 'Community'].includes(d.type)) return config.radii.platform;
            return config.radii.org;
        }, center.x, center.y).strength(0.8));

    let link = g.append("g").attr("class", "links").selectAll(".graph-link");
    let node = g.append("g").attr("class", "nodes").selectAll(".node");

    function restart() {
      const visibleNodes = nodes.filter(n => n.visible);
      const visibleLinks = links.filter(l => l.source.visible && l.target.visible);
      const openTagIds = new Set(nodes.filter(n => n.group === 'tag' && !n.collapsed).map(n => n.id));
      
      const bridgeNodes = new Set();
      visibleNodes.forEach(n => {
          if (n.group === 'tag') return;
          const myNeighbors = neighbors[n.id] || [];
          if (activeMode !== "DEFAULT") {
             if(myNeighbors.filter(nid => nodeMap.get(nid).visible).length >= 2) bridgeNodes.add(n.id);
          } else {
             if(myNeighbors.filter(nid => openTagIds.has(nid)).length >= 2) bridgeNodes.add(n.id);
          }
      });

      link = link.data(visibleLinks, d => d.source.id + "-" + d.target.id);
      link.exit().remove();
      link = link.enter().append("line").attr("class", "graph-link").merge(link);

      node = node.data(visibleNodes, d => d.id);
      node.exit().remove();
      const nodeEnter = node.enter().append("g").attr("class", "node")
          .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));
      nodeEnter.append("circle");
      nodeEnter.append("text").attr("class", "node-text").attr("dy", d => d.radius + 12).attr("text-anchor", "middle").text(d => d.label)
        .style("font-size", d => d.group === 'tag' ? "12px" : "10px");
      
      nodeEnter.on("click", handleNodeClick).on("mouseover", showTooltip).on("mouseout", hideTooltip);
      node = nodeEnter.merge(node);

      node.attr("class", d => {
        if(d.isCurrent) return "node node-current";
        if(bridgeNodes.has(d.id)) return "node node-bridge";
        return "node";
      });
      node.select("circle")
          .attr("class", d => {
              if (d.group === 'tag') return "node-circle node-tag";
              if (d.type === 'persoon') return "node-circle node-person";
              if (['Platform', 'Bibliotheek', 'Studio', 'Community'].includes(d.type)) return "node-circle node-platform";
              if (d.type === 'organisatie') return "node-circle node-org";
              return "node-circle node-init";
          })
          .attr("r", d => {
              if (d.isCurrent) return d.radius * 2.5;
              if (bridgeNodes.has(d.id)) return d.radius * 1.5;
              return d.radius;
          })
          .attr("fill", d => (d.group === 'tag' && !d.collapsed) ? getTagColor(d.id) : null)
          .attr("stroke", d => d.group === 'tag' ? getTagColor(d.id) : null)
          .attr("stroke-width", d => d.group === 'tag' ? 3 : null);

      simulation.nodes(visibleNodes);
      simulation.force("link").links(visibleLinks);
      simulation.alpha(1).restart();
    }

    function handleNodeClick(event, d) {
      event.stopPropagation();
      if (d.group !== 'tag') {
        if (d.url) window.location.href = d.url;
        return;
      }
      const myNeighbors = neighbors[d.id] || [];
      const childrenToToggle = nodes.filter(n => myNeighbors.includes(n.id) && n.group !== 'tag');
      
      if (childrenToToggle.length > 0) {
        d.collapsed = !d.collapsed;
        childrenToToggle.forEach(child => {
          if (!d.collapsed) { 
              child.visible = true; child.x = d.x; child.y = d.y; 
          } else if (activeMode === "DEFAULT") {
             const activeTags = nodes.filter(n => n.group === 'tag' && !n.collapsed && n.id !== d.id);
             const isShared = activeTags.some(tag => (neighbors[tag.id]||[]).includes(child.id));
             if (!isShared) child.visible = false;
          }
        });
        restart();
      }
    }

    const tooltip = d3.select(container.querySelector("#graph-tooltip"));
    function showTooltip(e, d) {
      d3.select(this).select("circle").attr("stroke", "#333").style("stroke-width", "3px");
      link.style("stroke-opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.05)
          .style("stroke", l => (l.source.id === d.id || l.target.id === d.id) ? "var(--main-color)" : null);
      tooltip.transition().duration(200).style("opacity", 1);
      tooltip.html(`<b>${d.label}</b><br/><small>${d.group==='tag'?'Thema':d.type}</small>`)
             .style("left", (e.pageX+15)+"px").style("top", (e.pageY-28)+"px");
    }
    function hideTooltip(e, d) { 
       tooltip.transition().duration(200).style("opacity",0); 
       d3.select(this).select("circle").attr("stroke", n => n.group === 'tag' ? getTagColor(n.id) : null).style("stroke-width", null);
       link.style("stroke-opacity", 0.4).style("stroke", null);
    }
    
    function zoomToFit() {
        const visibleNodes = nodes.filter(n => n.visible);
        if (visibleNodes.length === 0) {
           svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2).scale(0.8));
           return;
        }
        const box = { minX: d3.min(visibleNodes, d => d.x), maxX: d3.max(visibleNodes, d => d.x), minY: d3.min(visibleNodes, d => d.y), maxY: d3.max(visibleNodes, d => d.y) };
        const gw = box.maxX - box.minX + 60; const gh = box.maxY - box.minY + 60;
        if(isNaN(gw) || gw <= 60 || isNaN(gh) || gh <= 60) return;
        const scale = Math.min(2, 0.9 / Math.max(gw / width, gh / height));
        svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2).scale(scale).translate(-(box.minX+box.maxX)/2, -(box.minY+box.maxY)/2));
    }
    
    window.addEventListener('resize', () => {
      width = graphDiv.clientWidth; height = graphDiv.clientHeight;
      center = { x: width / 2, y: height / 2 };
      svg.attr("viewBox", [0, 0, width, height]);
      if(activeMode==="FOCUS" && focusId && nodeMap.has(focusId)) {
          const t = nodeMap.get(focusId); t.fx = center.x; t.fy = center.y;
      }
      simulation.force("r").x(center.x).y(center.y);
      simulation.alpha(0.3).restart();
    });

    container.querySelector('#toggle-btn').addEventListener('click', function() {
        let allExpanded = (this.innerText === "Alles inklappen");
        allExpanded = !allExpanded;
        nodes.forEach(n => {
             if(n.group === 'tag') {
                 n.collapsed = !allExpanded;
                 if(allExpanded) {
                     (neighbors[n.id]||[]).forEach(x => { if(nodeMap.get(x)) nodeMap.get(x).visible = true; });
                 }
             } else {
                 n.visible = allExpanded || n.group === 'tag' || (focusId && (n.id === focusId || (neighbors[focusId]||[]).includes(n.id)));
             }
        });
        this.innerText = allExpanded ? "Alles inklappen" : "Alles uitklappen";
        restart();
        setTimeout(zoomToFit, 1000);
    });

    function dragstarted(e, d) { if(!e.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
    function dragged(e, d) { d.fx=e.x; d.fy=e.y; }
    function dragended(e, d) { if(!e.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; }
    
    simulation.on("tick", () => {
      link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
      node.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    restart();
    setTimeout(() => {
        if(activeMode==="FOCUS" && focusId && nodeMap.has(focusId)) {
            const t = nodeMap.get(focusId); t.fx = null; t.fy = null;
        }
        zoomToFit();
    }, 1500);
  }).catch(err => {
    console.error("Network Graph Error:", err);
    container.querySelector("#loading").innerText = "Error loading data.";
  });
});
</script>